#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package SAPO::Broker::Codecs::Autogen::Thrift::DestinationType;
use constant TOPIC         => 0;
use constant QUEUE         => 1;
use constant VIRTUAL_QUEUE => 2;

package SAPO::Broker::Codecs::Autogen::Thrift::ActionType;
use constant PUBLISH      => 0;
use constant POLL         => 1;
use constant ACCEPTED     => 2;
use constant ACKNOWLEDGE  => 3;
use constant SUBSCRIBE    => 4;
use constant UNSUBSCRIBE  => 5;
use constant NOTIFICATION => 6;
use constant FAULT        => 7;
use constant PING         => 8;
use constant PONG         => 9;
use constant AUTH         => 10;

package SAPO::Broker::Codecs::Autogen::Thrift::Header;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Header->mk_accessors(qw( parameters ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{parameters} = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{parameters} ) {
            $self->{parameters} = $vals->{parameters};
        }
    }
    return bless( $self, $classname );
}

sub getName {
    return 'Header';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::MAP ) {
                    {
                        my $_size0 = 0;
                        $self->{parameters} = {};
                        my $_ktype1 = 0;
                        my $_vtype2 = 0;
                        $xfer += $input->readMapBegin( \$_ktype1, \$_vtype2, \$_size0 );
                        for ( my $_i4 = 0; $_i4 < $_size0; ++$_i4 ) {
                            my $key5 = '';
                            my $val6 = '';
                            $xfer += $input->readString( \$key5 );
                            $xfer += $input->readString( \$val6 );
                            $self->{parameters}->{$key5} = $val6;
                        }
                        $xfer += $input->readMapEnd();
                    }
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Header');
    if ( defined $self->{parameters} ) {
        $xfer += $output->writeFieldBegin( 'parameters', TType::MAP, 1 );
        {
            $output->writeMapBegin( TType::STRING, TType::STRING, scalar( keys %{ $self->{parameters} } ) );
            {
                while ( my ( $kiter7, $viter8 ) = each %{ $self->{parameters} } ) {
                    $xfer += $output->writeString($kiter7);
                    $xfer += $output->writeString($viter8);
                }
            }
            $output->writeMapEnd();
        }
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::BrokerMessage;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::BrokerMessage->mk_accessors(qw( message_id payload expiration timestamp ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{message_id} = undef;
    $self->{payload}    = undef;
    $self->{expiration} = undef;
    $self->{timestamp}  = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {

        if ( defined $vals->{message_id} ) {
            $self->{message_id} = $vals->{message_id};
        }
        if ( defined $vals->{payload} ) {
            $self->{payload} = $vals->{payload};
        }
        if ( defined $vals->{expiration} ) {
            $self->{expiration} = $vals->{expiration};
        }
        if ( defined $vals->{timestamp} ) {
            $self->{timestamp} = $vals->{timestamp};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'BrokerMessage';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{message_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{payload} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::I64 ) {
                    $xfer += $input->readI64( \$self->{expiration} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^4$/ && do {
                if ( $ftype == TType::I64 ) {
                    $xfer += $input->readI64( \$self->{timestamp} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('BrokerMessage');
    if ( defined $self->{message_id} ) {
        $xfer += $output->writeFieldBegin( 'message_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{message_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{payload} ) {
        $xfer += $output->writeFieldBegin( 'payload', TType::STRING, 2 );
        $xfer += $output->writeString( $self->{payload} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{expiration} ) {
        $xfer += $output->writeFieldBegin( 'expiration', TType::I64, 3 );
        $xfer += $output->writeI64( $self->{expiration} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{timestamp} ) {
        $xfer += $output->writeFieldBegin( 'timestamp', TType::I64, 4 );
        $xfer += $output->writeI64( $self->{timestamp} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Publish;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Publish->mk_accessors(qw( action_id destination_type destination message ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id}        = undef;
    $self->{destination_type} = undef;
    $self->{destination}      = undef;
    $self->{message}          = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {

        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
        if ( defined $vals->{destination_type} ) {
            $self->{destination_type} = $vals->{destination_type};
        }
        if ( defined $vals->{destination} ) {
            $self->{destination} = $vals->{destination};
        }
        if ( defined $vals->{message} ) {
            $self->{message} = $vals->{message};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Publish';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::I32 ) {
                    $xfer += $input->readI32( \$self->{destination_type} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{destination} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^4$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{message} = new SAPO::Broker::Codecs::Autogen::Thrift::BrokerMessage();
                    $xfer += $self->{message}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Publish');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination_type} ) {
        $xfer += $output->writeFieldBegin( 'destination_type', TType::I32, 2 );
        $xfer += $output->writeI32( $self->{destination_type} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination} ) {
        $xfer += $output->writeFieldBegin( 'destination', TType::STRING, 3 );
        $xfer += $output->writeString( $self->{destination} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{message} ) {
        $xfer += $output->writeFieldBegin( 'message', TType::STRUCT, 4 );
        $xfer += $self->{message}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Poll;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Poll->mk_accessors(qw( action_id destination timeout ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id}   = undef;
    $self->{destination} = undef;
    $self->{timeout}     = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
        if ( defined $vals->{destination} ) {
            $self->{destination} = $vals->{destination};
        }
        if ( defined $vals->{timeout} ) {
            $self->{timeout} = $vals->{timeout};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Poll';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{destination} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::I64 ) {
                    $xfer += $input->readI64( \$self->{timeout} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Poll');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination} ) {
        $xfer += $output->writeFieldBegin( 'destination', TType::STRING, 2 );
        $xfer += $output->writeString( $self->{destination} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{timeout} ) {
        $xfer += $output->writeFieldBegin( 'timeout', TType::I64, 3 );
        $xfer += $output->writeI64( $self->{timeout} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Accepted;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Accepted->mk_accessors(qw( action_id ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id} = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
    }
    return bless( $self, $classname );
}

sub getName {
    return 'Accepted';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        }
        $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Accepted');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
}

package SAPO::Broker::Codecs::Autogen::Thrift::Acknowledge;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Acknowledge->mk_accessors(qw( action_id message_id destination ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id}   = undef;
    $self->{message_id}  = undef;
    $self->{destination} = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
        if ( defined $vals->{message_id} ) {
            $self->{message_id} = $vals->{message_id};
        }
        if ( defined $vals->{destination} ) {
            $self->{destination} = $vals->{destination};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Acknowledge';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{message_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{destination} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Acknowledge');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{message_id} ) {
        $xfer += $output->writeFieldBegin( 'message_id', TType::STRING, 2 );
        $xfer += $output->writeString( $self->{message_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination} ) {
        $xfer += $output->writeFieldBegin( 'destination', TType::STRING, 3 );
        $xfer += $output->writeString( $self->{destination} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Subscribe;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Subscribe->mk_accessors(qw( action_id destination destination_type ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id}        = undef;
    $self->{destination}      = undef;
    $self->{destination_type} = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
        if ( defined $vals->{destination} ) {
            $self->{destination} = $vals->{destination};
        }
        if ( defined $vals->{destination_type} ) {
            $self->{destination_type} = $vals->{destination_type};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Subscribe';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{destination} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::I32 ) {
                    $xfer += $input->readI32( \$self->{destination_type} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Subscribe');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination} ) {
        $xfer += $output->writeFieldBegin( 'destination', TType::STRING, 2 );
        $xfer += $output->writeString( $self->{destination} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination_type} ) {
        $xfer += $output->writeFieldBegin( 'destination_type', TType::I32, 3 );
        $xfer += $output->writeI32( $self->{destination_type} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Unsubscribe;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Unsubscribe->mk_accessors(qw( action_id destination destination_type ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id}        = undef;
    $self->{destination}      = undef;
    $self->{destination_type} = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
        if ( defined $vals->{destination} ) {
            $self->{destination} = $vals->{destination};
        }
        if ( defined $vals->{destination_type} ) {
            $self->{destination_type} = $vals->{destination_type};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Unsubscribe';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{destination} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::I32 ) {
                    $xfer += $input->readI32( \$self->{destination_type} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Unsubscribe');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination} ) {
        $xfer += $output->writeFieldBegin( 'destination', TType::STRING, 2 );
        $xfer += $output->writeString( $self->{destination} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination_type} ) {
        $xfer += $output->writeFieldBegin( 'destination_type', TType::I32, 3 );
        $xfer += $output->writeI32( $self->{destination_type} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Notification;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Notification->mk_accessors(
    qw( destination subscription destination_type message ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{destination}      = undef;
    $self->{subscription}     = undef;
    $self->{destination_type} = undef;
    $self->{message}          = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {

        if ( defined $vals->{destination} ) {
            $self->{destination} = $vals->{destination};
        }
        if ( defined $vals->{subscription} ) {
            $self->{subscription} = $vals->{subscription};
        }
        if ( defined $vals->{destination_type} ) {
            $self->{destination_type} = $vals->{destination_type};
        }
        if ( defined $vals->{message} ) {
            $self->{message} = $vals->{message};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Notification';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{destination} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{subscription} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::I32 ) {
                    $xfer += $input->readI32( \$self->{destination_type} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^4$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{message} = new SAPO::Broker::Codecs::Autogen::Thrift::BrokerMessage();
                    $xfer += $self->{message}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Notification');
    if ( defined $self->{destination} ) {
        $xfer += $output->writeFieldBegin( 'destination', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{destination} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{subscription} ) {
        $xfer += $output->writeFieldBegin( 'subscription', TType::STRING, 2 );
        $xfer += $output->writeString( $self->{subscription} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{destination_type} ) {
        $xfer += $output->writeFieldBegin( 'destination_type', TType::I32, 3 );
        $xfer += $output->writeI32( $self->{destination_type} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{message} ) {
        $xfer += $output->writeFieldBegin( 'message', TType::STRUCT, 4 );
        $xfer += $self->{message}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Fault;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Fault->mk_accessors(qw( action_id fault_code fault_message fault_detail ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id}     = undef;
    $self->{fault_code}    = undef;
    $self->{fault_message} = undef;
    $self->{fault_detail}  = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {

        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
        if ( defined $vals->{fault_code} ) {
            $self->{fault_code} = $vals->{fault_code};
        }
        if ( defined $vals->{fault_message} ) {
            $self->{fault_message} = $vals->{fault_message};
        }
        if ( defined $vals->{fault_detail} ) {
            $self->{fault_detail} = $vals->{fault_detail};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Fault';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{fault_code} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{fault_message} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^4$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{fault_detail} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Fault');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{fault_code} ) {
        $xfer += $output->writeFieldBegin( 'fault_code', TType::STRING, 2 );
        $xfer += $output->writeString( $self->{fault_code} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{fault_message} ) {
        $xfer += $output->writeFieldBegin( 'fault_message', TType::STRING, 3 );
        $xfer += $output->writeString( $self->{fault_message} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{fault_detail} ) {
        $xfer += $output->writeFieldBegin( 'fault_detail', TType::STRING, 4 );
        $xfer += $output->writeString( $self->{fault_detail} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Ping;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Ping->mk_accessors(qw( action_id ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id} = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
    }
    return bless( $self, $classname );
}

sub getName {
    return 'Ping';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        }
        $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Ping');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
}

package SAPO::Broker::Codecs::Autogen::Thrift::Pong;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Pong->mk_accessors(qw( action_id ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id} = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
    }
    return bless( $self, $classname );
}

sub getName {
    return 'Pong';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        }
        $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Pong');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
}

package SAPO::Broker::Codecs::Autogen::Thrift::Authentication;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Authentication->mk_accessors(
    qw( action_id authentication_type token user_id roles ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{action_id}           = undef;
    $self->{authentication_type} = undef;
    $self->{token}               = undef;
    $self->{user_id}             = undef;
    $self->{roles}               = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {

        if ( defined $vals->{action_id} ) {
            $self->{action_id} = $vals->{action_id};
        }
        if ( defined $vals->{authentication_type} ) {
            $self->{authentication_type} = $vals->{authentication_type};
        }
        if ( defined $vals->{token} ) {
            $self->{token} = $vals->{token};
        }
        if ( defined $vals->{user_id} ) {
            $self->{user_id} = $vals->{user_id};
        }
        if ( defined $vals->{roles} ) {
            $self->{roles} = $vals->{roles};
        }
    }
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Authentication';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{action_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{authentication_type} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{token} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^4$/ && do {
                if ( $ftype == TType::STRING ) {
                    $xfer += $input->readString( \$self->{user_id} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^5$/ && do {
                if ( $ftype == TType::LIST ) {
                    {
                        my $_size9 = 0;
                        $self->{roles} = [];
                        my $_etype12 = 0;
                        $xfer += $input->readListBegin( \$_etype12, \$_size9 );
                        for ( my $_i13 = 0; $_i13 < $_size9; ++$_i13 ) {
                            my $elem14 = undef;
                            $xfer += $input->readString( \$elem14 );
                            push( @{ $self->{roles} }, $elem14 );
                        }
                        $xfer += $input->readListEnd();
                    }
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Authentication');
    if ( defined $self->{action_id} ) {
        $xfer += $output->writeFieldBegin( 'action_id', TType::STRING, 1 );
        $xfer += $output->writeString( $self->{action_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{authentication_type} ) {
        $xfer += $output->writeFieldBegin( 'authentication_type', TType::STRING, 2 );
        $xfer += $output->writeString( $self->{authentication_type} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{token} ) {
        $xfer += $output->writeFieldBegin( 'token', TType::STRING, 3 );
        $xfer += $output->writeString( $self->{token} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{user_id} ) {
        $xfer += $output->writeFieldBegin( 'user_id', TType::STRING, 4 );
        $xfer += $output->writeString( $self->{user_id} );
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{roles} ) {
        $xfer += $output->writeFieldBegin( 'roles', TType::LIST, 5 );
        {
            $output->writeListBegin( TType::STRING, scalar( @{ $self->{roles} } ) );
            {
                foreach my $iter15 ( @{ $self->{roles} } ) {
                    $xfer += $output->writeString($iter15);
                }
            }
            $output->writeListEnd();
        }
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Action;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Action->mk_accessors(
    qw( publish poll accepted ack_message subscribe unsubscribe notification fault ping pong auth action_type ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{publish}      = undef;
    $self->{poll}         = undef;
    $self->{accepted}     = undef;
    $self->{ack_message}  = undef;
    $self->{subscribe}    = undef;
    $self->{unsubscribe}  = undef;
    $self->{notification} = undef;
    $self->{fault}        = undef;
    $self->{ping}         = undef;
    $self->{pong}         = undef;
    $self->{auth}         = undef;
    $self->{action_type}  = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {

        if ( defined $vals->{publish} ) {
            $self->{publish} = $vals->{publish};
        }
        if ( defined $vals->{poll} ) {
            $self->{poll} = $vals->{poll};
        }
        if ( defined $vals->{accepted} ) {
            $self->{accepted} = $vals->{accepted};
        }
        if ( defined $vals->{ack_message} ) {
            $self->{ack_message} = $vals->{ack_message};
        }
        if ( defined $vals->{subscribe} ) {
            $self->{subscribe} = $vals->{subscribe};
        }
        if ( defined $vals->{unsubscribe} ) {
            $self->{unsubscribe} = $vals->{unsubscribe};
        }
        if ( defined $vals->{notification} ) {
            $self->{notification} = $vals->{notification};
        }
        if ( defined $vals->{fault} ) {
            $self->{fault} = $vals->{fault};
        }
        if ( defined $vals->{ping} ) {
            $self->{ping} = $vals->{ping};
        }
        if ( defined $vals->{pong} ) {
            $self->{pong} = $vals->{pong};
        }
        if ( defined $vals->{auth} ) {
            $self->{auth} = $vals->{auth};
        }
        if ( defined $vals->{action_type} ) {
            $self->{action_type} = $vals->{action_type};
        }
    } ## end if ( UNIVERSAL::isa( $vals...))
    return bless( $self, $classname );
} ## end sub new

sub getName {
    return 'Action';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{publish} = new SAPO::Broker::Codecs::Autogen::Thrift::Publish();
                    $xfer += $self->{publish}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{poll} = new SAPO::Broker::Codecs::Autogen::Thrift::Poll();
                    $xfer += $self->{poll}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^3$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{accepted} = new SAPO::Broker::Codecs::Autogen::Thrift::Accepted();
                    $xfer += $self->{accepted}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^4$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{ack_message} = new SAPO::Broker::Codecs::Autogen::Thrift::Acknowledge();
                    $xfer += $self->{ack_message}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^5$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{subscribe} = new SAPO::Broker::Codecs::Autogen::Thrift::Subscribe();
                    $xfer += $self->{subscribe}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^6$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{unsubscribe} = new SAPO::Broker::Codecs::Autogen::Thrift::Unsubscribe();
                    $xfer += $self->{unsubscribe}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^7$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{notification} = new SAPO::Broker::Codecs::Autogen::Thrift::Notification();
                    $xfer += $self->{notification}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^8$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{fault} = new SAPO::Broker::Codecs::Autogen::Thrift::Fault();
                    $xfer += $self->{fault}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^9$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{ping} = new SAPO::Broker::Codecs::Autogen::Thrift::Ping();
                    $xfer += $self->{ping}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^10$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{pong} = new SAPO::Broker::Codecs::Autogen::Thrift::Pong();
                    $xfer += $self->{pong}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^11$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{auth} = new SAPO::Broker::Codecs::Autogen::Thrift::Authentication();
                    $xfer += $self->{auth}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^12$/ && do {
                if ( $ftype == TType::I32 ) {
                    $xfer += $input->readI32( \$self->{action_type} );
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Action');
    if ( defined $self->{publish} ) {
        $xfer += $output->writeFieldBegin( 'publish', TType::STRUCT, 1 );
        $xfer += $self->{publish}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{poll} ) {
        $xfer += $output->writeFieldBegin( 'poll', TType::STRUCT, 2 );
        $xfer += $self->{poll}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{accepted} ) {
        $xfer += $output->writeFieldBegin( 'accepted', TType::STRUCT, 3 );
        $xfer += $self->{accepted}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{ack_message} ) {
        $xfer += $output->writeFieldBegin( 'ack_message', TType::STRUCT, 4 );
        $xfer += $self->{ack_message}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{subscribe} ) {
        $xfer += $output->writeFieldBegin( 'subscribe', TType::STRUCT, 5 );
        $xfer += $self->{subscribe}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{unsubscribe} ) {
        $xfer += $output->writeFieldBegin( 'unsubscribe', TType::STRUCT, 6 );
        $xfer += $self->{unsubscribe}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{notification} ) {
        $xfer += $output->writeFieldBegin( 'notification', TType::STRUCT, 7 );
        $xfer += $self->{notification}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{fault} ) {
        $xfer += $output->writeFieldBegin( 'fault', TType::STRUCT, 8 );
        $xfer += $self->{fault}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{ping} ) {
        $xfer += $output->writeFieldBegin( 'ping', TType::STRUCT, 9 );
        $xfer += $self->{ping}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{pong} ) {
        $xfer += $output->writeFieldBegin( 'pong', TType::STRUCT, 10 );
        $xfer += $self->{pong}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{auth} ) {
        $xfer += $output->writeFieldBegin( 'auth', TType::STRUCT, 11 );
        $xfer += $self->{auth}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{action_type} ) {
        $xfer += $output->writeFieldBegin( 'action_type', TType::I32, 12 );
        $xfer += $output->writeI32( $self->{action_type} );
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
} ## end sub write

package SAPO::Broker::Codecs::Autogen::Thrift::Atom;
use base qw(Class::Accessor);
SAPO::Broker::Codecs::Autogen::Thrift::Atom->mk_accessors(qw( header action ));

sub new {
    my $classname = shift;
    my $self      = {};
    my $vals      = shift || {};
    $self->{header} = undef;
    $self->{action} = undef;
    if ( UNIVERSAL::isa( $vals, 'HASH' ) ) {
        if ( defined $vals->{header} ) {
            $self->{header} = $vals->{header};
        }
        if ( defined $vals->{action} ) {
            $self->{action} = $vals->{action};
        }
    }
    return bless( $self, $classname );
}

sub getName {
    return 'Atom';
}

sub read {
    my ( $self, $input ) = @_;
    my $xfer = 0;
    my $fname;
    my $ftype = 0;
    my $fid   = 0;
    $xfer += $input->readStructBegin( \$fname );
    while (1) {
        $xfer += $input->readFieldBegin( \$fname, \$ftype, \$fid );
        if ( $ftype == TType::STOP ) {
            last;
        }
    SWITCH: for ($fid) {
            /^1$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{header} = new SAPO::Broker::Codecs::Autogen::Thrift::Header();
                    $xfer += $self->{header}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            /^2$/ && do {
                if ( $ftype == TType::STRUCT ) {
                    $self->{action} = new SAPO::Broker::Codecs::Autogen::Thrift::Action();
                    $xfer += $self->{action}->read($input);
                } else {
                    $xfer += $input->skip($ftype);
                }
                last;
            };
            $xfer += $input->skip($ftype);
        } ## end for ($fid)
        $xfer += $input->readFieldEnd();
    } ## end while (1)
    $xfer += $input->readStructEnd();
    return $xfer;
} ## end sub read

sub write {
    my ( $self, $output ) = @_;
    my $xfer = 0;
    $xfer += $output->writeStructBegin('Atom');
    if ( defined $self->{header} ) {
        $xfer += $output->writeFieldBegin( 'header', TType::STRUCT, 1 );
        $xfer += $self->{header}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    if ( defined $self->{action} ) {
        $xfer += $output->writeFieldBegin( 'action', TType::STRUCT, 2 );
        $xfer += $self->{action}->write($output);
        $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
}

1;
